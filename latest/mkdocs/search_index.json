{
    "docs": [
        {
            "location": "/", 
            "text": "ImagesCore.jl\n\n\nImagesCore is the lowest-level component of the system of packages designed to support image processing and computer vision. Its main role is to simplify \"conversions\" between different image representations through different \"view\" types, and to provide some useful low-level \"traits\" that simplify the writing of algorithms.\n\n\n\n\nViews\n\n\nTraits\n\n\nReference\n\n\nList of view types\n\n\nList of traits", 
            "title": "Home"
        }, 
        {
            "location": "/#imagescorejl", 
            "text": "ImagesCore is the lowest-level component of the system of packages designed to support image processing and computer vision. Its main role is to simplify \"conversions\" between different image representations through different \"view\" types, and to provide some useful low-level \"traits\" that simplify the writing of algorithms.   Views  Traits  Reference  List of view types  List of traits", 
            "title": "ImagesCore.jl"
        }, 
        {
            "location": "/views/", 
            "text": "Views\n\n\nImagesCore provides several different kinds of \"views.\" Generically, a view is an \ninterpretation\n of array data, one that may change the apparent meaning of the array but which shares the same underlying storage: change an element of the view, and you also change the original array. Views allow one to process images of immense size without making copies, and write algorithms in the most convenient format often without having to worry about the potential cost of converting from one format to another.\n\n\nTo illustrate views, it's helpful to begin with a very simple image:\n\n\njulia\n using Colors\n\njulia\n img = [RGB(1,0,0) RGB(0,1,0);\n              RGB(0,0,1) RGB(0,0,0)]\n2\u00d72 Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}:\n RGB{U8}(1.0,0.0,0.0)  RGB{U8}(0.0,1.0,0.0)\n RGB{U8}(0.0,0.0,1.0)  RGB{U8}(0.0,0.0,0.0)\n\n\n\n\nRGB\n is described in the \nColors package\n, and the image is just a plain 2\u00d72 array containing red, green, blue, and black pixels.  In Julia's color package, \"1\" means \"saturated\" (e.g., \"full red\"), and \"0\" means \"black\".  In a moment you'll see that's true no matter how the information is represented internally.\n\n\nAs with all of Julia's arrays, you can access individual elements:\n\n\njulia\n img[1,2]\nRGB{U8}(0.0,1.0,0.0)\n\n\n\n\nOne of the nice things about this representation of the image is that all of the indices in \nimg[i,j,...]\n correspond to locations in the image: you don't need to worry about some dimensions of the array corresponding to \"color channels\" and other the spatial location, and you're guaranteed to get the entire pixel contents when you access that location.\n\n\nThat said, occassionally there are reasons to want to treat \nRGB\n as a 3-component vector.  That's motivation for introducing our first view:\n\n\njulia\n v = channelview(img)\n3\u00d72\u00d72 ImagesCore.ChannelView{FixedPointNumbers.UFixed{UInt8,8},3,Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}}:\n[:, :, 1] =\n UFixed8(1.0)  UFixed8(0.0)\n UFixed8(0.0)  UFixed8(0.0)\n UFixed8(0.0)  UFixed8(1.0)\n\n[:, :, 2] =\n UFixed8(0.0)  UFixed8(0.0)\n UFixed8(1.0)  UFixed8(0.0)\n UFixed8(0.0)  UFixed8(0.0)\n\n\n\n\nv\n is a 3\u00d72\u00d72 array of numbers (\nUFixed8\n is defined in \nFixedPointNumbers\n and can be abbreviated as \nU8\n), where the three elements of the first dimension correspond to the red, green, and blue color channels, respectively. \nchannelview\n does exactly what the name suggests: provide a view of the array using separate channels for the color components.\n\n\nIf you're not familiar with \nUFixed8\n, then you may find another view type, \nrawview\n, illuminating:\n\n\njulia\n r = rawview(v)\n3\u00d72\u00d72 MappedArrays.MappedArray{UInt8,3,ImagesCore.ChannelView{FixedPointNumbers.UFixed{UInt8,8},3,Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}},ImagesCore.##11#13,ImagesCore.##12#14{FixedPointNumbers.UFixed{UInt8,8}}}:\n[:, :, 1] =\n 0xff  0x00\n 0x00  0x00\n 0x00  0xff\n\n[:, :, 2] =\n 0x00  0x00\n 0xff  0x00\n 0x00  0x00\n\n\n\n\nThis is an array of \nUInt8\n numbers, with 0 printed as 0x00 and 255 printed as 0xff. Despite the apparent \"floating point\" representation of the image above, we see that it's actually represented using 8-bit unsigned integers.  The \nUFixed8\n type presents such an integer as a fixed-point number ranging from 0 to 1.  As a consequence, there is no discrepancy in \"meaning\" between the encoding of images represented as floating point or 8-bit or 16-bit integers: 0 always means \"black\" and 1 always means \"white\" or \"saturated.\"\n\n\nLet's make a change in one of the entries:\n\n\njulia\n r[3,1,1] = 128\n128\n\njulia\n r\n3\u00d72\u00d72 MappedArrays.MappedArray{UInt8,3,ImagesCore.ChannelView{FixedPointNumbers.UFixed{UInt8,8},3,Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}},ImagesCore.##11#13,ImagesCore.##12#14{FixedPointNumbers.UFixed{UInt8,8}}}:\n[:, :, 1] =\n 0xff  0x00\n 0x00  0x00\n 0x80  0xff\n\n[:, :, 2] =\n 0x00  0x00\n 0xff  0x00\n 0x00  0x00\n\njulia\n v\n3\u00d72\u00d72 ImagesCore.ChannelView{FixedPointNumbers.UFixed{UInt8,8},3,Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}}:\n[:, :, 1] =\n UFixed8(1.0)    UFixed8(0.0)\n UFixed8(0.0)    UFixed8(0.0)\n UFixed8(0.502)  UFixed8(1.0)\n\n[:, :, 2] =\n UFixed8(0.0)  UFixed8(0.0)\n UFixed8(1.0)  UFixed8(0.0)\n UFixed8(0.0)  UFixed8(0.0)\n\njulia\n img\n2\u00d72 Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}:\n RGB{U8}(1.0,0.0,0.502)  RGB{U8}(0.0,1.0,0.0)\n RGB{U8}(0.0,0.0,1.0)    RGB{U8}(0.0,0.0,0.0)\n\n\n\n\nThe hexidecimal representation of 128 is 0x80; this is approximately halfway to 255, and as a consequence the \nUFixed8\n representation is very near 0.5.  You can see the same change is reflected in \nr\n, \nv\n, and \nimg\n: there is only one underlying array, \nimg\n, and the two views simply reference it.\n\n\nMaybe you're used to having the color channel be the last dimension, rather than the first. We can achieve that using \npermuteddimsview\n:\n\n\njulia\n p = permuteddimsview(v, (2,3,1))\n2\u00d72\u00d73 Base.PermutedDimsArrays.PermutedDimsArray{FixedPointNumbers.UFixed{UInt8,8},3,(2,3,1),(3,1,2),ImagesCore.ChannelView{FixedPointNumbers.UFixed{UInt8,8},3,Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}}}:\n[:, :, 1] =\n UFixed8(1.0)  UFixed8(0.0)\n UFixed8(0.0)  UFixed8(0.0)\n\n[:, :, 2] =\n UFixed8(0.0)  UFixed8(1.0)\n UFixed8(0.0)  UFixed8(0.0)\n\n[:, :, 3] =\n UFixed8(0.502)  UFixed8(0.0)\n UFixed8(1.0)    UFixed8(0.0)\n\njulia\n p[1,2,:] = 0.25\n0.25\n\njulia\n p\n2\u00d72\u00d73 Base.PermutedDimsArrays.PermutedDimsArray{FixedPointNumbers.UFixed{UInt8,8},3,(2,3,1),(3,1,2),ImagesCore.ChannelView{FixedPointNumbers.UFixed{UInt8,8},3,Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}}}:\n[:, :, 1] =\n UFixed8(1.0)  UFixed8(0.251)\n UFixed8(0.0)  UFixed8(0.0)\n\n[:, :, 2] =\n UFixed8(0.0)  UFixed8(0.251)\n UFixed8(0.0)  UFixed8(0.0)\n\n[:, :, 3] =\n UFixed8(0.502)  UFixed8(0.251)\n UFixed8(1.0)    UFixed8(0.0)\n\njulia\n v\n3\u00d72\u00d72 ImagesCore.ChannelView{FixedPointNumbers.UFixed{UInt8,8},3,Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}}:\n[:, :, 1] =\n UFixed8(1.0)    UFixed8(0.0)\n UFixed8(0.0)    UFixed8(0.0)\n UFixed8(0.502)  UFixed8(1.0)\n\n[:, :, 2] =\n UFixed8(0.251)  UFixed8(0.0)\n UFixed8(0.251)  UFixed8(0.0)\n UFixed8(0.251)  UFixed8(0.0)\n\njulia\n img\n2\u00d72 Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}:\n RGB{U8}(1.0,0.0,0.502)  RGB{U8}(0.251,0.251,0.251)\n RGB{U8}(0.0,0.0,1.0)    RGB{U8}(0.0,0.0,0.0)\n\n\n\n\nOnce again, \np\n is a view, and as a consequence changing it leads to changes in all the coupled arrays and views.", 
            "title": "Views"
        }, 
        {
            "location": "/views/#views", 
            "text": "ImagesCore provides several different kinds of \"views.\" Generically, a view is an  interpretation  of array data, one that may change the apparent meaning of the array but which shares the same underlying storage: change an element of the view, and you also change the original array. Views allow one to process images of immense size without making copies, and write algorithms in the most convenient format often without having to worry about the potential cost of converting from one format to another.  To illustrate views, it's helpful to begin with a very simple image:  julia  using Colors\n\njulia  img = [RGB(1,0,0) RGB(0,1,0);\n              RGB(0,0,1) RGB(0,0,0)]\n2\u00d72 Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}:\n RGB{U8}(1.0,0.0,0.0)  RGB{U8}(0.0,1.0,0.0)\n RGB{U8}(0.0,0.0,1.0)  RGB{U8}(0.0,0.0,0.0)  RGB  is described in the  Colors package , and the image is just a plain 2\u00d72 array containing red, green, blue, and black pixels.  In Julia's color package, \"1\" means \"saturated\" (e.g., \"full red\"), and \"0\" means \"black\".  In a moment you'll see that's true no matter how the information is represented internally.  As with all of Julia's arrays, you can access individual elements:  julia  img[1,2]\nRGB{U8}(0.0,1.0,0.0)  One of the nice things about this representation of the image is that all of the indices in  img[i,j,...]  correspond to locations in the image: you don't need to worry about some dimensions of the array corresponding to \"color channels\" and other the spatial location, and you're guaranteed to get the entire pixel contents when you access that location.  That said, occassionally there are reasons to want to treat  RGB  as a 3-component vector.  That's motivation for introducing our first view:  julia  v = channelview(img)\n3\u00d72\u00d72 ImagesCore.ChannelView{FixedPointNumbers.UFixed{UInt8,8},3,Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}}:\n[:, :, 1] =\n UFixed8(1.0)  UFixed8(0.0)\n UFixed8(0.0)  UFixed8(0.0)\n UFixed8(0.0)  UFixed8(1.0)\n\n[:, :, 2] =\n UFixed8(0.0)  UFixed8(0.0)\n UFixed8(1.0)  UFixed8(0.0)\n UFixed8(0.0)  UFixed8(0.0)  v  is a 3\u00d72\u00d72 array of numbers ( UFixed8  is defined in  FixedPointNumbers  and can be abbreviated as  U8 ), where the three elements of the first dimension correspond to the red, green, and blue color channels, respectively.  channelview  does exactly what the name suggests: provide a view of the array using separate channels for the color components.  If you're not familiar with  UFixed8 , then you may find another view type,  rawview , illuminating:  julia  r = rawview(v)\n3\u00d72\u00d72 MappedArrays.MappedArray{UInt8,3,ImagesCore.ChannelView{FixedPointNumbers.UFixed{UInt8,8},3,Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}},ImagesCore.##11#13,ImagesCore.##12#14{FixedPointNumbers.UFixed{UInt8,8}}}:\n[:, :, 1] =\n 0xff  0x00\n 0x00  0x00\n 0x00  0xff\n\n[:, :, 2] =\n 0x00  0x00\n 0xff  0x00\n 0x00  0x00  This is an array of  UInt8  numbers, with 0 printed as 0x00 and 255 printed as 0xff. Despite the apparent \"floating point\" representation of the image above, we see that it's actually represented using 8-bit unsigned integers.  The  UFixed8  type presents such an integer as a fixed-point number ranging from 0 to 1.  As a consequence, there is no discrepancy in \"meaning\" between the encoding of images represented as floating point or 8-bit or 16-bit integers: 0 always means \"black\" and 1 always means \"white\" or \"saturated.\"  Let's make a change in one of the entries:  julia  r[3,1,1] = 128\n128\n\njulia  r\n3\u00d72\u00d72 MappedArrays.MappedArray{UInt8,3,ImagesCore.ChannelView{FixedPointNumbers.UFixed{UInt8,8},3,Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}},ImagesCore.##11#13,ImagesCore.##12#14{FixedPointNumbers.UFixed{UInt8,8}}}:\n[:, :, 1] =\n 0xff  0x00\n 0x00  0x00\n 0x80  0xff\n\n[:, :, 2] =\n 0x00  0x00\n 0xff  0x00\n 0x00  0x00\n\njulia  v\n3\u00d72\u00d72 ImagesCore.ChannelView{FixedPointNumbers.UFixed{UInt8,8},3,Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}}:\n[:, :, 1] =\n UFixed8(1.0)    UFixed8(0.0)\n UFixed8(0.0)    UFixed8(0.0)\n UFixed8(0.502)  UFixed8(1.0)\n\n[:, :, 2] =\n UFixed8(0.0)  UFixed8(0.0)\n UFixed8(1.0)  UFixed8(0.0)\n UFixed8(0.0)  UFixed8(0.0)\n\njulia  img\n2\u00d72 Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}:\n RGB{U8}(1.0,0.0,0.502)  RGB{U8}(0.0,1.0,0.0)\n RGB{U8}(0.0,0.0,1.0)    RGB{U8}(0.0,0.0,0.0)  The hexidecimal representation of 128 is 0x80; this is approximately halfway to 255, and as a consequence the  UFixed8  representation is very near 0.5.  You can see the same change is reflected in  r ,  v , and  img : there is only one underlying array,  img , and the two views simply reference it.  Maybe you're used to having the color channel be the last dimension, rather than the first. We can achieve that using  permuteddimsview :  julia  p = permuteddimsview(v, (2,3,1))\n2\u00d72\u00d73 Base.PermutedDimsArrays.PermutedDimsArray{FixedPointNumbers.UFixed{UInt8,8},3,(2,3,1),(3,1,2),ImagesCore.ChannelView{FixedPointNumbers.UFixed{UInt8,8},3,Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}}}:\n[:, :, 1] =\n UFixed8(1.0)  UFixed8(0.0)\n UFixed8(0.0)  UFixed8(0.0)\n\n[:, :, 2] =\n UFixed8(0.0)  UFixed8(1.0)\n UFixed8(0.0)  UFixed8(0.0)\n\n[:, :, 3] =\n UFixed8(0.502)  UFixed8(0.0)\n UFixed8(1.0)    UFixed8(0.0)\n\njulia  p[1,2,:] = 0.25\n0.25\n\njulia  p\n2\u00d72\u00d73 Base.PermutedDimsArrays.PermutedDimsArray{FixedPointNumbers.UFixed{UInt8,8},3,(2,3,1),(3,1,2),ImagesCore.ChannelView{FixedPointNumbers.UFixed{UInt8,8},3,Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}}}:\n[:, :, 1] =\n UFixed8(1.0)  UFixed8(0.251)\n UFixed8(0.0)  UFixed8(0.0)\n\n[:, :, 2] =\n UFixed8(0.0)  UFixed8(0.251)\n UFixed8(0.0)  UFixed8(0.0)\n\n[:, :, 3] =\n UFixed8(0.502)  UFixed8(0.251)\n UFixed8(1.0)    UFixed8(0.0)\n\njulia  v\n3\u00d72\u00d72 ImagesCore.ChannelView{FixedPointNumbers.UFixed{UInt8,8},3,Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}}:\n[:, :, 1] =\n UFixed8(1.0)    UFixed8(0.0)\n UFixed8(0.0)    UFixed8(0.0)\n UFixed8(0.502)  UFixed8(1.0)\n\n[:, :, 2] =\n UFixed8(0.251)  UFixed8(0.0)\n UFixed8(0.251)  UFixed8(0.0)\n UFixed8(0.251)  UFixed8(0.0)\n\njulia  img\n2\u00d72 Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}:\n RGB{U8}(1.0,0.0,0.502)  RGB{U8}(0.251,0.251,0.251)\n RGB{U8}(0.0,0.0,1.0)    RGB{U8}(0.0,0.0,0.0)  Once again,  p  is a view, and as a consequence changing it leads to changes in all the coupled arrays and views.", 
            "title": "Views"
        }, 
        {
            "location": "/traits/", 
            "text": "Traits\n\n\nImagesCore supports several \"traits\" that are sometimes useful in viewing or analyzing images. Many of these traits become much more powerful if you are using add-on packages like ImagesAxes, which allows you to give \"physical meaning\" to the different axes of your image.  Readers are encouraged to view the documentation for ImageAxes to gain a better appreciation of how to exploit these traits.  When using plain arrays to represent images, most of the traits default to \"trivial\" outcomes.\n\n\nLet's illustrate with a couple of examples:\n\n\njulia\n using Colors, ImagesCore\n\njulia\n img = rand(RGB{U8}, 680, 480);\n\njulia\n pixelspacing(img)\n(1,1)\n\n\n\n\npixelspacing\n returns the spacing between adjacent pixels along each axis. Using ImagesAxes, you can even use physical units to encode this information, for example for use in microscopy or biomedical imaging.\n\n\njulia\n coords_spatial(img)\n(1,2)\n\n\n\n\nThis trait indicates that both dimensions 1 and 2 are \"spatial dimensions,\" meaning they correspond to physical space. This trait again becomes more interesting with ImagesAxes, where you can denote that some axes correspond to time (e.g., for a movie).\n\n\nA full list of traits is presented in the reference section.", 
            "title": "Traits"
        }, 
        {
            "location": "/traits/#traits", 
            "text": "ImagesCore supports several \"traits\" that are sometimes useful in viewing or analyzing images. Many of these traits become much more powerful if you are using add-on packages like ImagesAxes, which allows you to give \"physical meaning\" to the different axes of your image.  Readers are encouraged to view the documentation for ImageAxes to gain a better appreciation of how to exploit these traits.  When using plain arrays to represent images, most of the traits default to \"trivial\" outcomes.  Let's illustrate with a couple of examples:  julia  using Colors, ImagesCore\n\njulia  img = rand(RGB{U8}, 680, 480);\n\njulia  pixelspacing(img)\n(1,1)  pixelspacing  returns the spacing between adjacent pixels along each axis. Using ImagesAxes, you can even use physical units to encode this information, for example for use in microscopy or biomedical imaging.  julia  coords_spatial(img)\n(1,2)  This trait indicates that both dimensions 1 and 2 are \"spatial dimensions,\" meaning they correspond to physical space. This trait again becomes more interesting with ImagesAxes, where you can denote that some axes correspond to time (e.g., for a movie).  A full list of traits is presented in the reference section.", 
            "title": "Traits"
        }, 
        {
            "location": "/reference/", 
            "text": "Reference\n\n\n\n\nList of view types\n\n\nWith that as an introduction, let's list all the view types supported by this package.  \nchannelview\n and \ncolorview\n are opposite transformations, as are \nrawview\n and \nufixedview\n. \nchannelview\n and \ncolorview\n typically create objects of type \nChannelView\n and \nColorView\n, respectively, unless they are \"undoing\" a previous view of the opposite type.\n\n\nchannelview\nChannelView\ncolorview\nColorView\nrawview\nufixedview\npermuteddimsview\n\n\n\n\n\n\nList of traits\n\n\n#\n\n\nImagesCore.pixelspacing\n \n \nFunction\n.\n\n\npixelspacing(img) -\n (sx, sy, ...)\n\n\n\n\nReturn a tuple representing the separation between adjacent pixels along each axis of the image.  Defaults to (1,1,...).  Use ImagesAxes for images with anisotropic spacing or to encode the spacing using physical units.\n\n\nsource\n\n\n#\n\n\nImagesCore.spacedirections\n \n \nFunction\n.\n\n\nspacedirections(img) -\n (axis1, axis2, ...)\n\n\n\n\nReturn a tuple-of-tuples, each \naxis[i]\n representing the displacement vector between adjacent pixels along spatial axis \ni\n of the image array, relative to some external coordinate system (\"physical coordinates\").\n\n\nBy default this is computed from \npixelspacing\n, but you can set this manually using ImagesMeta.\n\n\nsource\n\n\n#\n\n\nImagesCore.sdims\n \n \nFunction\n.\n\n\nsdims(img)\n\n\n\n\nReturn the number of spatial dimensions in the image. Defaults to the same as \nndims\n, but with ImagesAxes you can specify that some axes correspond to other quantities (e.g., time) and thus not included by \nsdims\n.\n\n\nsource\n\n\n#\n\n\nImagesCore.coords_spatial\n \n \nFunction\n.\n\n\ncoords_spatial(img)\n\n\nReturn a tuple listing the spatial dimensions of \nimg\n.\n\n\nNote that a better strategy may be to use ImagesAxes and take slices along the time axis.\n\n\nsource\n\n\n#\n\n\nImagesCore.size_spatial\n \n \nFunction\n.\n\n\nsize_spatial(img)\n\n\n\n\nReturn a tuple listing the sizes of the spatial dimensions of the image. Defaults to the same as \nsize\n, but using ImagesAxes you can mark some axes as being non-spatial.\n\n\nsource\n\n\n#\n\n\nImagesCore.indices_spatial\n \n \nFunction\n.\n\n\nindices_spatial(img)\n\n\n\n\nReturn a tuple with the indices of the spatial dimensions of the image. Defaults to the same as \nindices\n, but using ImagesAxes you can mark some axes as being non-spatial.\n\n\nsource\n\n\n#\n\n\nImagesCore.nimages\n \n \nFunction\n.\n\n\nnimages(img)\n\n\n\n\nReturn the number of time-points in the image array. Defaults to\n\n\n\n\nUse ImagesAxes if you want to use an explicit time dimension.\n\n\n\n\nsource\n\n\n#\n\n\nImagesCore.assert_timedim_last\n \n \nFunction\n.\n\n\nassert_timedim_last(img)\n\n\n\n\nThrow an error if the image has a time dimension that is not the last dimension.\n\n\nsource", 
            "title": "Reference"
        }, 
        {
            "location": "/reference/#reference", 
            "text": "", 
            "title": "Reference"
        }, 
        {
            "location": "/reference/#list-of-view-types", 
            "text": "With that as an introduction, let's list all the view types supported by this package.   channelview  and  colorview  are opposite transformations, as are  rawview  and  ufixedview .  channelview  and  colorview  typically create objects of type  ChannelView  and  ColorView , respectively, unless they are \"undoing\" a previous view of the opposite type.  channelview\nChannelView\ncolorview\nColorView\nrawview\nufixedview\npermuteddimsview", 
            "title": "List of view types"
        }, 
        {
            "location": "/reference/#list-of-traits", 
            "text": "#  ImagesCore.pixelspacing     Function .  pixelspacing(img) -  (sx, sy, ...)  Return a tuple representing the separation between adjacent pixels along each axis of the image.  Defaults to (1,1,...).  Use ImagesAxes for images with anisotropic spacing or to encode the spacing using physical units.  source  #  ImagesCore.spacedirections     Function .  spacedirections(img) -  (axis1, axis2, ...)  Return a tuple-of-tuples, each  axis[i]  representing the displacement vector between adjacent pixels along spatial axis  i  of the image array, relative to some external coordinate system (\"physical coordinates\").  By default this is computed from  pixelspacing , but you can set this manually using ImagesMeta.  source  #  ImagesCore.sdims     Function .  sdims(img)  Return the number of spatial dimensions in the image. Defaults to the same as  ndims , but with ImagesAxes you can specify that some axes correspond to other quantities (e.g., time) and thus not included by  sdims .  source  #  ImagesCore.coords_spatial     Function .  coords_spatial(img)  Return a tuple listing the spatial dimensions of  img .  Note that a better strategy may be to use ImagesAxes and take slices along the time axis.  source  #  ImagesCore.size_spatial     Function .  size_spatial(img)  Return a tuple listing the sizes of the spatial dimensions of the image. Defaults to the same as  size , but using ImagesAxes you can mark some axes as being non-spatial.  source  #  ImagesCore.indices_spatial     Function .  indices_spatial(img)  Return a tuple with the indices of the spatial dimensions of the image. Defaults to the same as  indices , but using ImagesAxes you can mark some axes as being non-spatial.  source  #  ImagesCore.nimages     Function .  nimages(img)  Return the number of time-points in the image array. Defaults to   Use ImagesAxes if you want to use an explicit time dimension.   source  #  ImagesCore.assert_timedim_last     Function .  assert_timedim_last(img)  Throw an error if the image has a time dimension that is not the last dimension.  source", 
            "title": "List of traits"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "The ImagesCore.jl package is licensed under the MIT \"Expat\" License:\n\n\n\n\nCopyright (c) 2015: Tim Holy.\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }
    ]
}