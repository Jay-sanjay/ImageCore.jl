{
    "docs": [
        {
            "location": "/", 
            "text": "ImagesCore.jl\n\n\nImagesCore is the lowest-level component of the system of packages designed to support image processing and computer vision. Its main role is to simplify \"conversions\" between different image representations through different \"view\" types, and to provide some useful low-level \"traits\" that simplify the writing of algorithms.\n\n\n\n\nViews\n\n\nTraits\n\n\nReference\n\n\nList of view types\n\n\nList of traits", 
            "title": "Home"
        }, 
        {
            "location": "/#imagescorejl", 
            "text": "ImagesCore is the lowest-level component of the system of packages designed to support image processing and computer vision. Its main role is to simplify \"conversions\" between different image representations through different \"view\" types, and to provide some useful low-level \"traits\" that simplify the writing of algorithms.   Views  Traits  Reference  List of view types  List of traits", 
            "title": "ImagesCore.jl"
        }, 
        {
            "location": "/views/", 
            "text": "Views\n\n\nImagesCore provides several different kinds of \"views.\" Generically, a view is an \ninterpretation\n of array data, one that may change the apparent meaning of the array but which shares the same underlying storage: change an element of the view, and you also change the original array. Views allow one to process images of immense size without making copies, and write algorithms in the most convenient format often without having to worry about the potential cost of converting from one format to another.\n\n\nTo illustrate views, it's helpful to begin with a very simple image:\n\n\njulia\n using Colors\n\njulia\n img = [RGB(1,0,0) RGB(0,1,0);\n              RGB(0,0,1) RGB(0,0,0)]\n2\u00d72 Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}:\n RGB{U8}(1.0,0.0,0.0)  RGB{U8}(0.0,1.0,0.0)\n RGB{U8}(0.0,0.0,1.0)  RGB{U8}(0.0,0.0,0.0)\n\n\n\n\nRGB\n is described in the \nColors package\n, and the image is just a plain 2\u00d72 array containing red, green, blue, and black pixels.  In Julia's color package, \"1\" means \"saturated\" (e.g., \"full red\"), and \"0\" means \"black\".  In a moment you'll see that's true no matter how the information is represented internally.\n\n\nAs with all of Julia's arrays, you can access individual elements:\n\n\njulia\n img[1,2]\nRGB{U8}(0.0,1.0,0.0)\n\n\n\n\nOne of the nice things about this representation of the image is that all of the indices in \nimg[i,j,...]\n correspond to locations in the image: you don't need to worry about some dimensions of the array corresponding to \"color channels\" and other the spatial location, and you're guaranteed to get the entire pixel contents when you access that location.\n\n\nThat said, occassionally there are reasons to want to treat \nRGB\n as a 3-component vector.  That's motivation for introducing our first view:\n\n\njulia\n v = channelview(img)\n3\u00d72\u00d72 ImagesCore.ChannelView{FixedPointNumbers.UFixed{UInt8,8},3,Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}}:\n[:, :, 1] =\n UFixed8(1.0)  UFixed8(0.0)\n UFixed8(0.0)  UFixed8(0.0)\n UFixed8(0.0)  UFixed8(1.0)\n\n[:, :, 2] =\n UFixed8(0.0)  UFixed8(0.0)\n UFixed8(1.0)  UFixed8(0.0)\n UFixed8(0.0)  UFixed8(0.0)\n\n\n\n\nv\n is a 3\u00d72\u00d72 array of numbers (\nUFixed8\n is defined in \nFixedPointNumbers\n and can be abbreviated as \nU8\n), where the three elements of the first dimension correspond to the red, green, and blue color channels, respectively. \nchannelview\n does exactly what the name suggests: provide a view of the array using separate channels for the color components.\n\n\nIf you're not familiar with \nUFixed8\n, then you may find another view type, \nrawview\n, illuminating:\n\n\njulia\n r = rawview(v)\n3\u00d72\u00d72 MappedArrays.MappedArray{UInt8,3,ImagesCore.ChannelView{FixedPointNumbers.UFixed{UInt8,8},3,Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}},ImagesCore.##11#13,ImagesCore.##12#14{FixedPointNumbers.UFixed{UInt8,8}}}:\n[:, :, 1] =\n 0xff  0x00\n 0x00  0x00\n 0x00  0xff\n\n[:, :, 2] =\n 0x00  0x00\n 0xff  0x00\n 0x00  0x00\n\n\n\n\nThis is an array of \nUInt8\n numbers, with 0 printed as 0x00 and 255 printed as 0xff. Despite the apparent \"floating point\" representation of the image above, we see that it's actually represented using 8-bit unsigned integers.  The \nUFixed8\n type presents such an integer as a fixed-point number ranging from 0 to 1.  As a consequence, there is no discrepancy in \"meaning\" between the encoding of images represented as floating point or 8-bit or 16-bit integers: 0 always means \"black\" and 1 always means \"white\" or \"saturated.\"\n\n\nLet's make a change in one of the entries:\n\n\njulia\n r[3,1,1] = 128\n128\n\njulia\n r\n3\u00d72\u00d72 MappedArrays.MappedArray{UInt8,3,ImagesCore.ChannelView{FixedPointNumbers.UFixed{UInt8,8},3,Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}},ImagesCore.##11#13,ImagesCore.##12#14{FixedPointNumbers.UFixed{UInt8,8}}}:\n[:, :, 1] =\n 0xff  0x00\n 0x00  0x00\n 0x80  0xff\n\n[:, :, 2] =\n 0x00  0x00\n 0xff  0x00\n 0x00  0x00\n\njulia\n v\n3\u00d72\u00d72 ImagesCore.ChannelView{FixedPointNumbers.UFixed{UInt8,8},3,Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}}:\n[:, :, 1] =\n UFixed8(1.0)    UFixed8(0.0)\n UFixed8(0.0)    UFixed8(0.0)\n UFixed8(0.502)  UFixed8(1.0)\n\n[:, :, 2] =\n UFixed8(0.0)  UFixed8(0.0)\n UFixed8(1.0)  UFixed8(0.0)\n UFixed8(0.0)  UFixed8(0.0)\n\njulia\n img\n2\u00d72 Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}:\n RGB{U8}(1.0,0.0,0.502)  RGB{U8}(0.0,1.0,0.0)\n RGB{U8}(0.0,0.0,1.0)    RGB{U8}(0.0,0.0,0.0)\n\n\n\n\nThe hexidecimal representation of 128 is 0x80; this is approximately halfway to 255, and as a consequence the \nUFixed8\n representation is very near 0.5.  You can see the same change is reflected in \nr\n, \nv\n, and \nimg\n: there is only one underlying array, \nimg\n, and the two views simply reference it.\n\n\nMaybe you're used to having the color channel be the last dimension, rather than the first. We can achieve that using \npermuteddimsview\n:\n\n\njulia\n p = permuteddimsview(v, (2,3,1))\n2\u00d72\u00d73 Base.PermutedDimsArrays.PermutedDimsArray{FixedPointNumbers.UFixed{UInt8,8},3,(2,3,1),(3,1,2),ImagesCore.ChannelView{FixedPointNumbers.UFixed{UInt8,8},3,Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}}}:\n[:, :, 1] =\n UFixed8(1.0)  UFixed8(0.0)\n UFixed8(0.0)  UFixed8(0.0)\n\n[:, :, 2] =\n UFixed8(0.0)  UFixed8(1.0)\n UFixed8(0.0)  UFixed8(0.0)\n\n[:, :, 3] =\n UFixed8(0.502)  UFixed8(0.0)\n UFixed8(1.0)    UFixed8(0.0)\n\njulia\n p[1,2,:] = 0.25\n0.25\n\njulia\n p\n2\u00d72\u00d73 Base.PermutedDimsArrays.PermutedDimsArray{FixedPointNumbers.UFixed{UInt8,8},3,(2,3,1),(3,1,2),ImagesCore.ChannelView{FixedPointNumbers.UFixed{UInt8,8},3,Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}}}:\n[:, :, 1] =\n UFixed8(1.0)  UFixed8(0.251)\n UFixed8(0.0)  UFixed8(0.0)\n\n[:, :, 2] =\n UFixed8(0.0)  UFixed8(0.251)\n UFixed8(0.0)  UFixed8(0.0)\n\n[:, :, 3] =\n UFixed8(0.502)  UFixed8(0.251)\n UFixed8(1.0)    UFixed8(0.0)\n\njulia\n v\n3\u00d72\u00d72 ImagesCore.ChannelView{FixedPointNumbers.UFixed{UInt8,8},3,Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}}:\n[:, :, 1] =\n UFixed8(1.0)    UFixed8(0.0)\n UFixed8(0.0)    UFixed8(0.0)\n UFixed8(0.502)  UFixed8(1.0)\n\n[:, :, 2] =\n UFixed8(0.251)  UFixed8(0.0)\n UFixed8(0.251)  UFixed8(0.0)\n UFixed8(0.251)  UFixed8(0.0)\n\njulia\n img\n2\u00d72 Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}:\n RGB{U8}(1.0,0.0,0.502)  RGB{U8}(0.251,0.251,0.251)\n RGB{U8}(0.0,0.0,1.0)    RGB{U8}(0.0,0.0,0.0)\n\n\n\n\nOnce again, \np\n is a view, and as a consequence changing it leads to changes in all the coupled arrays and views.", 
            "title": "Views"
        }, 
        {
            "location": "/views/#views", 
            "text": "ImagesCore provides several different kinds of \"views.\" Generically, a view is an  interpretation  of array data, one that may change the apparent meaning of the array but which shares the same underlying storage: change an element of the view, and you also change the original array. Views allow one to process images of immense size without making copies, and write algorithms in the most convenient format often without having to worry about the potential cost of converting from one format to another.  To illustrate views, it's helpful to begin with a very simple image:  julia  using Colors\n\njulia  img = [RGB(1,0,0) RGB(0,1,0);\n              RGB(0,0,1) RGB(0,0,0)]\n2\u00d72 Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}:\n RGB{U8}(1.0,0.0,0.0)  RGB{U8}(0.0,1.0,0.0)\n RGB{U8}(0.0,0.0,1.0)  RGB{U8}(0.0,0.0,0.0)  RGB  is described in the  Colors package , and the image is just a plain 2\u00d72 array containing red, green, blue, and black pixels.  In Julia's color package, \"1\" means \"saturated\" (e.g., \"full red\"), and \"0\" means \"black\".  In a moment you'll see that's true no matter how the information is represented internally.  As with all of Julia's arrays, you can access individual elements:  julia  img[1,2]\nRGB{U8}(0.0,1.0,0.0)  One of the nice things about this representation of the image is that all of the indices in  img[i,j,...]  correspond to locations in the image: you don't need to worry about some dimensions of the array corresponding to \"color channels\" and other the spatial location, and you're guaranteed to get the entire pixel contents when you access that location.  That said, occassionally there are reasons to want to treat  RGB  as a 3-component vector.  That's motivation for introducing our first view:  julia  v = channelview(img)\n3\u00d72\u00d72 ImagesCore.ChannelView{FixedPointNumbers.UFixed{UInt8,8},3,Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}}:\n[:, :, 1] =\n UFixed8(1.0)  UFixed8(0.0)\n UFixed8(0.0)  UFixed8(0.0)\n UFixed8(0.0)  UFixed8(1.0)\n\n[:, :, 2] =\n UFixed8(0.0)  UFixed8(0.0)\n UFixed8(1.0)  UFixed8(0.0)\n UFixed8(0.0)  UFixed8(0.0)  v  is a 3\u00d72\u00d72 array of numbers ( UFixed8  is defined in  FixedPointNumbers  and can be abbreviated as  U8 ), where the three elements of the first dimension correspond to the red, green, and blue color channels, respectively.  channelview  does exactly what the name suggests: provide a view of the array using separate channels for the color components.  If you're not familiar with  UFixed8 , then you may find another view type,  rawview , illuminating:  julia  r = rawview(v)\n3\u00d72\u00d72 MappedArrays.MappedArray{UInt8,3,ImagesCore.ChannelView{FixedPointNumbers.UFixed{UInt8,8},3,Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}},ImagesCore.##11#13,ImagesCore.##12#14{FixedPointNumbers.UFixed{UInt8,8}}}:\n[:, :, 1] =\n 0xff  0x00\n 0x00  0x00\n 0x00  0xff\n\n[:, :, 2] =\n 0x00  0x00\n 0xff  0x00\n 0x00  0x00  This is an array of  UInt8  numbers, with 0 printed as 0x00 and 255 printed as 0xff. Despite the apparent \"floating point\" representation of the image above, we see that it's actually represented using 8-bit unsigned integers.  The  UFixed8  type presents such an integer as a fixed-point number ranging from 0 to 1.  As a consequence, there is no discrepancy in \"meaning\" between the encoding of images represented as floating point or 8-bit or 16-bit integers: 0 always means \"black\" and 1 always means \"white\" or \"saturated.\"  Let's make a change in one of the entries:  julia  r[3,1,1] = 128\n128\n\njulia  r\n3\u00d72\u00d72 MappedArrays.MappedArray{UInt8,3,ImagesCore.ChannelView{FixedPointNumbers.UFixed{UInt8,8},3,Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}},ImagesCore.##11#13,ImagesCore.##12#14{FixedPointNumbers.UFixed{UInt8,8}}}:\n[:, :, 1] =\n 0xff  0x00\n 0x00  0x00\n 0x80  0xff\n\n[:, :, 2] =\n 0x00  0x00\n 0xff  0x00\n 0x00  0x00\n\njulia  v\n3\u00d72\u00d72 ImagesCore.ChannelView{FixedPointNumbers.UFixed{UInt8,8},3,Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}}:\n[:, :, 1] =\n UFixed8(1.0)    UFixed8(0.0)\n UFixed8(0.0)    UFixed8(0.0)\n UFixed8(0.502)  UFixed8(1.0)\n\n[:, :, 2] =\n UFixed8(0.0)  UFixed8(0.0)\n UFixed8(1.0)  UFixed8(0.0)\n UFixed8(0.0)  UFixed8(0.0)\n\njulia  img\n2\u00d72 Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}:\n RGB{U8}(1.0,0.0,0.502)  RGB{U8}(0.0,1.0,0.0)\n RGB{U8}(0.0,0.0,1.0)    RGB{U8}(0.0,0.0,0.0)  The hexidecimal representation of 128 is 0x80; this is approximately halfway to 255, and as a consequence the  UFixed8  representation is very near 0.5.  You can see the same change is reflected in  r ,  v , and  img : there is only one underlying array,  img , and the two views simply reference it.  Maybe you're used to having the color channel be the last dimension, rather than the first. We can achieve that using  permuteddimsview :  julia  p = permuteddimsview(v, (2,3,1))\n2\u00d72\u00d73 Base.PermutedDimsArrays.PermutedDimsArray{FixedPointNumbers.UFixed{UInt8,8},3,(2,3,1),(3,1,2),ImagesCore.ChannelView{FixedPointNumbers.UFixed{UInt8,8},3,Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}}}:\n[:, :, 1] =\n UFixed8(1.0)  UFixed8(0.0)\n UFixed8(0.0)  UFixed8(0.0)\n\n[:, :, 2] =\n UFixed8(0.0)  UFixed8(1.0)\n UFixed8(0.0)  UFixed8(0.0)\n\n[:, :, 3] =\n UFixed8(0.502)  UFixed8(0.0)\n UFixed8(1.0)    UFixed8(0.0)\n\njulia  p[1,2,:] = 0.25\n0.25\n\njulia  p\n2\u00d72\u00d73 Base.PermutedDimsArrays.PermutedDimsArray{FixedPointNumbers.UFixed{UInt8,8},3,(2,3,1),(3,1,2),ImagesCore.ChannelView{FixedPointNumbers.UFixed{UInt8,8},3,Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}}}:\n[:, :, 1] =\n UFixed8(1.0)  UFixed8(0.251)\n UFixed8(0.0)  UFixed8(0.0)\n\n[:, :, 2] =\n UFixed8(0.0)  UFixed8(0.251)\n UFixed8(0.0)  UFixed8(0.0)\n\n[:, :, 3] =\n UFixed8(0.502)  UFixed8(0.251)\n UFixed8(1.0)    UFixed8(0.0)\n\njulia  v\n3\u00d72\u00d72 ImagesCore.ChannelView{FixedPointNumbers.UFixed{UInt8,8},3,Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}}:\n[:, :, 1] =\n UFixed8(1.0)    UFixed8(0.0)\n UFixed8(0.0)    UFixed8(0.0)\n UFixed8(0.502)  UFixed8(1.0)\n\n[:, :, 2] =\n UFixed8(0.251)  UFixed8(0.0)\n UFixed8(0.251)  UFixed8(0.0)\n UFixed8(0.251)  UFixed8(0.0)\n\njulia  img\n2\u00d72 Array{ColorTypes.RGB{FixedPointNumbers.UFixed{UInt8,8}},2}:\n RGB{U8}(1.0,0.0,0.502)  RGB{U8}(0.251,0.251,0.251)\n RGB{U8}(0.0,0.0,1.0)    RGB{U8}(0.0,0.0,0.0)  Once again,  p  is a view, and as a consequence changing it leads to changes in all the coupled arrays and views.", 
            "title": "Views"
        }, 
        {
            "location": "/traits/", 
            "text": "Traits\n\n\nImagesCore supports several \"traits\" that are sometimes useful in viewing or analyzing images. Many of these traits become much more powerful if you are using add-on packages like ImagesAxes, which allows you to give \"physical meaning\" to the different axes of your image.  Readers are encouraged to view the documentation for ImageAxes to gain a better appreciation of how to exploit these traits.  When using plain arrays to represent images, most of the traits default to \"trivial\" outcomes.\n\n\nLet's illustrate with a couple of examples:\n\n\njulia\n using Colors, ImagesCore\n\njulia\n img = rand(RGB{U8}, 680, 480);\n\njulia\n pixelspacing(img)\n(1,1)\n\n\n\n\npixelspacing\n returns the spacing between adjacent pixels along each axis. Using ImagesAxes, you can even use physical units to encode this information, for example for use in microscopy or biomedical imaging.\n\n\njulia\n coords_spatial(img)\n(1,2)\n\n\n\n\nThis trait indicates that both dimensions 1 and 2 are \"spatial dimensions,\" meaning they correspond to physical space. This trait again becomes more interesting with ImagesAxes, where you can denote that some axes correspond to time (e.g., for a movie).\n\n\nA full list of traits is presented in the reference section.", 
            "title": "Traits"
        }, 
        {
            "location": "/traits/#traits", 
            "text": "ImagesCore supports several \"traits\" that are sometimes useful in viewing or analyzing images. Many of these traits become much more powerful if you are using add-on packages like ImagesAxes, which allows you to give \"physical meaning\" to the different axes of your image.  Readers are encouraged to view the documentation for ImageAxes to gain a better appreciation of how to exploit these traits.  When using plain arrays to represent images, most of the traits default to \"trivial\" outcomes.  Let's illustrate with a couple of examples:  julia  using Colors, ImagesCore\n\njulia  img = rand(RGB{U8}, 680, 480);\n\njulia  pixelspacing(img)\n(1,1)  pixelspacing  returns the spacing between adjacent pixels along each axis. Using ImagesAxes, you can even use physical units to encode this information, for example for use in microscopy or biomedical imaging.  julia  coords_spatial(img)\n(1,2)  This trait indicates that both dimensions 1 and 2 are \"spatial dimensions,\" meaning they correspond to physical space. This trait again becomes more interesting with ImagesAxes, where you can denote that some axes correspond to time (e.g., for a movie).  A full list of traits is presented in the reference section.", 
            "title": "Traits"
        }, 
        {
            "location": "/reference/", 
            "text": "Reference\n\n\n\n\nList of view types\n\n\nWith that as an introduction, let's list all the view types supported by this package.  \nchannelview\n and \ncolorview\n are opposite transformations, as are \nrawview\n and \nufixedview\n. \nchannelview\n and \ncolorview\n typically create objects of type \nChannelView\n and \nColorView\n, respectively, unless they are \"undoing\" a previous view of the opposite type.\n\n\n#\n\n\nImagesCore.channelview\n \n \nFunction\n.\n\n\nchannelview(A)\n\n\n\n\nreturns a view of \nA\n, splitting out (if necessary) the color channels of \nA\n into a new first dimension. This is almost identical to \nChannelView(A)\n, except that if \nA\n is a \nColorView\n, it will simply return the parent of \nA\n (and hence may not be a \nChannelView\n array).\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nchannelview\n(\nA\n::\nImagesCore.ColorView\n)\n\n    defined at\n    \nsrc/colorchannels.jl:174\n\n\n\n\n\n    \nchannelview\n(\nA\n::\nAbstractArray\n)\n\n    defined at\n    \nsrc/colorchannels.jl:173\n\n\n\n\n\n\n\n#\n\n\nImagesCore.ChannelView\n \n \nType\n.\n\n\nChannelView(A)\n\n\n\n\ncreates a \"view\" of the Colorant array \nA\n, splitting out (if necessary) the separate color channels of \neltype(A)\n into a new first dimension. For example, if \nA\n is a m-by-n RGB{U8} array, \nChannelView(A)\n will return a 3-by-m-by-n U8 array. Color spaces with a single element (i.e., grayscale) do not add a new first dimension of \nA\n.\n\n\nOf relevance for types like RGB and BGR, the channels of the returned array will be in constructor-argument order, not memory order (see \nreinterpret\n if you want to use memory order).\n\n\nThe opposite transformation is implemented by \nColorView\n.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nChannelView\n(\nparent\n::\nAbstractArray\n)\n\n    defined at\n    \nsrc/colorchannels.jl:55\n\n\n\n\n\n\n\nHiding 1 method defined outside of this package.\n\n\n#\n\n\nImagesCore.colorview\n \n \nFunction\n.\n\n\ncolorview(C, A)\n\n\n\n\nreturns a view of the numeric array \nA\n, interpreting successive elements of \nA\n as if they were channels of Colorant \nC\n. This is almost identical to \nColorView{C}(A)\n, except that if \nA\n is a \nChannelView\n, it will simply return the parent of \nA\n (and hence may not be a \nColorView\n array).\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \ncolorview\n{\nC\n<\n:ColorTypes.Colorant{T,N}\n}\n(\n\n    \n::\nType{C}\n,\n\n    \nA\n::\nImagesCore.ChannelView\n\n\n)\n\n    defined at\n    \nsrc/colorchannels.jl:187\n\n\n\n\n\n    \ncolorview\n{\nC\n<\n:ColorTypes.Colorant{T,N}\n}\n(\n::\nType{C}\n, \nA\n::\nAbstractArray\n)\n\n    defined at\n    \nsrc/colorchannels.jl:185\n\n\n\n\n\n\n\n#\n\n\nImagesCore.ColorView\n \n \nType\n.\n\n\nMethods\n\n\n\n\n\n    \nColorView\n(\n::\nAbstractArray\n)\n\n    defined at\n    \nsrc/colorchannels.jl:134\n\n\n\n\n\n\n\nHiding 1 method defined outside of this package.\n\n\n#\n\n\nImagesCore.rawview\n \n \nFunction\n.\n\n\nrawview(img::AbstractArray{FixedPoint})\n\n\n\n\nreturns a \"view\" of \nimg\n where the values are interpreted in terms of their raw underlying storage. For example, if \nimg\n is an \nArray{U8}\n, the view will act like an \nArray{UInt8}\n.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nrawview\n{\nT\n<\n:FixedPointNumbers.FixedPoint{T\n<\n:Integer,f}\n}\n(\na\n::\nAbstractArray{T,N\n<\n:Any}\n)\n\n    defined at\n    \nsrc/ImagesCore.jl:57\n\n\n\n\n\n    \nrawview\n{\nT\n<\n:Real\n}\n(\na\n::\nAbstractArray{T,N\n<\n:Any}\n)\n\n    defined at\n    \nsrc/ImagesCore.jl:58\n\n\n\n\n\n\n\n#\n\n\nImagesCore.ufixedview\n \n \nFunction\n.\n\n\nufixedview([T], img::AbstractArray{Unsigned})\n\n\n\n\nreturns a \"view\" of \nimg\n where the values are interpreted in terms of \nUFixed\n number types. For example, if \nimg\n is an \nArray{UInt8}\n, the view will act like an \nArray{UFixed8}\n.  Supply \nT\n if the element type of \nimg\n is \nUInt16\n, to specify whether you want a \nUFixed10\n, \nUFixed12\n, \nUFixed14\n, or \nUFixed16\n result.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nufixedview\n{\nT\n<\n:FixedPointNumbers.FixedPoint{T\n<\n:Integer,f}\n, \nS\n<\n:Unsigned\n}\n(\n\n    \n::\nType{T}\n,\n\n    \na\n::\nAbstractArray{S,N\n<\n:Any}\n\n\n)\n\n    defined at\n    \nsrc/ImagesCore.jl:69\n\n\n\n\n\n    \nufixedview\n(\na\n::\nAbstractArray{UInt8,N\n<\n:Any}\n)\n\n    defined at\n    \nsrc/ImagesCore.jl:70\n\n\n\n\n\n    \nufixedview\n{\nT\n<\n:FixedPointNumbers.UFixed{T\n<\n:Unsigned,f}\n}\n(\n\n    \n::\nType{T}\n,\n\n    \na\n::\nAbstractArray{T,N\n<\n:Any}\n\n\n)\n\n    defined at\n    \nsrc/ImagesCore.jl:71\n\n\n\n\n\n\n\n#\n\n\nImagesCore.permuteddimsview\n \n \nFunction\n.\n\n\npermuteddimsview(A, perm)\n\n\n\n\nreturns a \"view\" of \nA\n with its dimensions permuted as specified by \nperm\n. This is like \npermutedims\n, except that it produces a view rather than a copy of \nA\n; consequently, any manipulations you make to the output will be mirrored in \nA\n. Compared to the copy, the view is much faster to create, but generally slower to use.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \npermuteddimsview\n(\nA\n, \nperm\n)\n\n    defined at\n    \nsrc/ImagesCore.jl:82\n\n\n\n\n\n\n\n\n\nList of traits\n\n\n#\n\n\nImagesCore.pixelspacing\n \n \nFunction\n.\n\n\npixelspacing(img) -\n (sx, sy, ...)\n\n\n\n\nReturn a tuple representing the separation between adjacent pixels along each axis of the image.  Defaults to (1,1,...).  Use ImagesAxes for images with anisotropic spacing or to encode the spacing using physical units.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \npixelspacing\n{\nT\n, \nN\n}\n(\nimg\n::\nAbstractArray{T,N}\n)\n\n    defined at\n    \nsrc/traits.jl:9\n\n\n\n\n\n\n\n#\n\n\nImagesCore.spacedirections\n \n \nFunction\n.\n\n\nspacedirections(img) -\n (axis1, axis2, ...)\n\n\n\n\nReturn a tuple-of-tuples, each \naxis[i]\n representing the displacement vector between adjacent pixels along spatial axis \ni\n of the image array, relative to some external coordinate system (\"physical coordinates\").\n\n\nBy default this is computed from \npixelspacing\n, but you can set this manually using ImagesMeta.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nspacedirections\n(\nimg\n::\nAbstractArray\n)\n\n    defined at\n    \nsrc/traits.jl:22\n\n\n\n\n\n\n\n#\n\n\nImagesCore.sdims\n \n \nFunction\n.\n\n\nsdims(img)\n\n\n\n\nReturn the number of spatial dimensions in the image. Defaults to the same as \nndims\n, but with ImagesAxes you can specify that some axes correspond to other quantities (e.g., time) and thus not included by \nsdims\n.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nsdims\n(\nimg\n::\nAbstractArray\n)\n\n    defined at\n    \nsrc/traits.jl:35\n\n\n\n\n\n\n\n#\n\n\nImagesCore.coords_spatial\n \n \nFunction\n.\n\n\ncoords_spatial(img)\n\n\nReturn a tuple listing the spatial dimensions of \nimg\n.\n\n\nNote that a better strategy may be to use ImagesAxes and take slices along the time axis.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \ncoords_spatial\n{\nT\n, \nN\n}\n(\nimg\n::\nAbstractArray{T,N}\n)\n\n    defined at\n    \nsrc/traits.jl:44\n\n\n\n\n\n\n\n#\n\n\nImagesCore.size_spatial\n \n \nFunction\n.\n\n\nsize_spatial(img)\n\n\n\n\nReturn a tuple listing the sizes of the spatial dimensions of the image. Defaults to the same as \nsize\n, but using ImagesAxes you can mark some axes as being non-spatial.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nsize_spatial\n(\nimg\n)\n\n    defined at\n    \nsrc/traits.jl:61\n\n\n\n\n\n\n\n#\n\n\nImagesCore.indices_spatial\n \n \nFunction\n.\n\n\nindices_spatial(img)\n\n\n\n\nReturn a tuple with the indices of the spatial dimensions of the image. Defaults to the same as \nindices\n, but using ImagesAxes you can mark some axes as being non-spatial.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nindices_spatial\n(\nimg\n)\n\n    defined at\n    \nsrc/traits.jl:70\n\n\n\n\n\n\n\n#\n\n\nImagesCore.nimages\n \n \nFunction\n.\n\n\nnimages(img)\n\n\n\n\nReturn the number of time-points in the image array. Defaults to 1. Use ImagesAxes if you want to use an explicit time dimension.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nnimages\n(\nimg\n::\nAbstractArray\n)\n\n    defined at\n    \nsrc/traits.jl:52\n\n\n\n\n\n\n\n#\n\n\nImagesCore.assert_timedim_last\n \n \nFunction\n.\n\n\nassert_timedim_last(img)\n\n\n\n\nThrow an error if the image has a time dimension that is not the last dimension.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nassert_timedim_last\n(\nimg\n::\nAbstractArray\n)\n\n    defined at\n    \nsrc/traits.jl:81", 
            "title": "Reference"
        }, 
        {
            "location": "/reference/#reference", 
            "text": "", 
            "title": "Reference"
        }, 
        {
            "location": "/reference/#list-of-view-types", 
            "text": "With that as an introduction, let's list all the view types supported by this package.   channelview  and  colorview  are opposite transformations, as are  rawview  and  ufixedview .  channelview  and  colorview  typically create objects of type  ChannelView  and  ColorView , respectively, unless they are \"undoing\" a previous view of the opposite type.  #  ImagesCore.channelview     Function .  channelview(A)  returns a view of  A , splitting out (if necessary) the color channels of  A  into a new first dimension. This is almost identical to  ChannelView(A) , except that if  A  is a  ColorView , it will simply return the parent of  A  (and hence may not be a  ChannelView  array).  source  Methods   \n     channelview ( A :: ImagesCore.ColorView ) \n    defined at\n     src/colorchannels.jl:174   \n     channelview ( A :: AbstractArray ) \n    defined at\n     src/colorchannels.jl:173    #  ImagesCore.ChannelView     Type .  ChannelView(A)  creates a \"view\" of the Colorant array  A , splitting out (if necessary) the separate color channels of  eltype(A)  into a new first dimension. For example, if  A  is a m-by-n RGB{U8} array,  ChannelView(A)  will return a 3-by-m-by-n U8 array. Color spaces with a single element (i.e., grayscale) do not add a new first dimension of  A .  Of relevance for types like RGB and BGR, the channels of the returned array will be in constructor-argument order, not memory order (see  reinterpret  if you want to use memory order).  The opposite transformation is implemented by  ColorView .  source  Methods   \n     ChannelView ( parent :: AbstractArray ) \n    defined at\n     src/colorchannels.jl:55    Hiding 1 method defined outside of this package.  #  ImagesCore.colorview     Function .  colorview(C, A)  returns a view of the numeric array  A , interpreting successive elements of  A  as if they were channels of Colorant  C . This is almost identical to  ColorView{C}(A) , except that if  A  is a  ChannelView , it will simply return the parent of  A  (and hence may not be a  ColorView  array).  source  Methods   \n     colorview { C < :ColorTypes.Colorant{T,N} } ( \n     :: Type{C} ,      A :: ImagesCore.ChannelView  ) \n    defined at\n     src/colorchannels.jl:187   \n     colorview { C < :ColorTypes.Colorant{T,N} } ( :: Type{C} ,  A :: AbstractArray ) \n    defined at\n     src/colorchannels.jl:185    #  ImagesCore.ColorView     Type .  Methods   \n     ColorView ( :: AbstractArray ) \n    defined at\n     src/colorchannels.jl:134    Hiding 1 method defined outside of this package.  #  ImagesCore.rawview     Function .  rawview(img::AbstractArray{FixedPoint})  returns a \"view\" of  img  where the values are interpreted in terms of their raw underlying storage. For example, if  img  is an  Array{U8} , the view will act like an  Array{UInt8} .  source  Methods   \n     rawview { T < :FixedPointNumbers.FixedPoint{T < :Integer,f} } ( a :: AbstractArray{T,N < :Any} ) \n    defined at\n     src/ImagesCore.jl:57   \n     rawview { T < :Real } ( a :: AbstractArray{T,N < :Any} ) \n    defined at\n     src/ImagesCore.jl:58    #  ImagesCore.ufixedview     Function .  ufixedview([T], img::AbstractArray{Unsigned})  returns a \"view\" of  img  where the values are interpreted in terms of  UFixed  number types. For example, if  img  is an  Array{UInt8} , the view will act like an  Array{UFixed8} .  Supply  T  if the element type of  img  is  UInt16 , to specify whether you want a  UFixed10 ,  UFixed12 ,  UFixed14 , or  UFixed16  result.  source  Methods   \n     ufixedview { T < :FixedPointNumbers.FixedPoint{T < :Integer,f} ,  S < :Unsigned } ( \n     :: Type{T} ,      a :: AbstractArray{S,N < :Any}  ) \n    defined at\n     src/ImagesCore.jl:69   \n     ufixedview ( a :: AbstractArray{UInt8,N < :Any} ) \n    defined at\n     src/ImagesCore.jl:70   \n     ufixedview { T < :FixedPointNumbers.UFixed{T < :Unsigned,f} } ( \n     :: Type{T} ,      a :: AbstractArray{T,N < :Any}  ) \n    defined at\n     src/ImagesCore.jl:71    #  ImagesCore.permuteddimsview     Function .  permuteddimsview(A, perm)  returns a \"view\" of  A  with its dimensions permuted as specified by  perm . This is like  permutedims , except that it produces a view rather than a copy of  A ; consequently, any manipulations you make to the output will be mirrored in  A . Compared to the copy, the view is much faster to create, but generally slower to use.  source  Methods   \n     permuteddimsview ( A ,  perm ) \n    defined at\n     src/ImagesCore.jl:82", 
            "title": "List of view types"
        }, 
        {
            "location": "/reference/#list-of-traits", 
            "text": "#  ImagesCore.pixelspacing     Function .  pixelspacing(img) -  (sx, sy, ...)  Return a tuple representing the separation between adjacent pixels along each axis of the image.  Defaults to (1,1,...).  Use ImagesAxes for images with anisotropic spacing or to encode the spacing using physical units.  source  Methods   \n     pixelspacing { T ,  N } ( img :: AbstractArray{T,N} ) \n    defined at\n     src/traits.jl:9    #  ImagesCore.spacedirections     Function .  spacedirections(img) -  (axis1, axis2, ...)  Return a tuple-of-tuples, each  axis[i]  representing the displacement vector between adjacent pixels along spatial axis  i  of the image array, relative to some external coordinate system (\"physical coordinates\").  By default this is computed from  pixelspacing , but you can set this manually using ImagesMeta.  source  Methods   \n     spacedirections ( img :: AbstractArray ) \n    defined at\n     src/traits.jl:22    #  ImagesCore.sdims     Function .  sdims(img)  Return the number of spatial dimensions in the image. Defaults to the same as  ndims , but with ImagesAxes you can specify that some axes correspond to other quantities (e.g., time) and thus not included by  sdims .  source  Methods   \n     sdims ( img :: AbstractArray ) \n    defined at\n     src/traits.jl:35    #  ImagesCore.coords_spatial     Function .  coords_spatial(img)  Return a tuple listing the spatial dimensions of  img .  Note that a better strategy may be to use ImagesAxes and take slices along the time axis.  source  Methods   \n     coords_spatial { T ,  N } ( img :: AbstractArray{T,N} ) \n    defined at\n     src/traits.jl:44    #  ImagesCore.size_spatial     Function .  size_spatial(img)  Return a tuple listing the sizes of the spatial dimensions of the image. Defaults to the same as  size , but using ImagesAxes you can mark some axes as being non-spatial.  source  Methods   \n     size_spatial ( img ) \n    defined at\n     src/traits.jl:61    #  ImagesCore.indices_spatial     Function .  indices_spatial(img)  Return a tuple with the indices of the spatial dimensions of the image. Defaults to the same as  indices , but using ImagesAxes you can mark some axes as being non-spatial.  source  Methods   \n     indices_spatial ( img ) \n    defined at\n     src/traits.jl:70    #  ImagesCore.nimages     Function .  nimages(img)  Return the number of time-points in the image array. Defaults to 1. Use ImagesAxes if you want to use an explicit time dimension.  source  Methods   \n     nimages ( img :: AbstractArray ) \n    defined at\n     src/traits.jl:52    #  ImagesCore.assert_timedim_last     Function .  assert_timedim_last(img)  Throw an error if the image has a time dimension that is not the last dimension.  source  Methods   \n     assert_timedim_last ( img :: AbstractArray ) \n    defined at\n     src/traits.jl:81", 
            "title": "List of traits"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "The ImagesCore.jl package is licensed under the MIT \"Expat\" License:\n\n\n\n\nCopyright (c) 2015: Tim Holy.\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }
    ]
}